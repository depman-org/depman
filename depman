#!/usr/bin/env -S nu --no-config-file --no-history

const NAME = 'Depman'
const VERSION = '0.1.0'
const NU_VERSION = '0.98.0'
const GITHUB_URL: string = 'https://github.com/rayanamal/depman'
const CLI_NAME = $NAME | str downcase
const DEPMAN_DIR: path = $CLI_NAME
const default_paths = {
	out-dir: 'artifacts/'
	cache-dir: 'cache/'
	dependencies_file: 'dependencies.toml'
	lockfile: 'dependencies.lock'
	commands_script: 'commands.nu'
}

const path_separator = if $nu.os-info.family == unix {'/'} else {'\'}
let nu_version: string = try { (version).version } catch { 'unknown' }
if $nu_version != $NU_VERSION {
	error $"Your Nushell version is not compatible with ($NAME). Required Nushell version is ($NU_VERSION | ans green).\nYou can download different versions of Nushell here: https://github.com/nushell/nushell/releases"
}

def 'main test' [] {
	$env.prt_json = false
	
	'htht' | check-type int datetime --err-msg {|value, value_type, accepted_types| {messasge: $"value: ($value)\n sitnri \nninist", hint: $"Please don't do shit like this ok ($accepted_types)"}} 
}

# Depman is the simplest possible project dependency manager, build system and command runner all in one.
#
# Documentation: https://github.com/rayanamal/depman
def main [
	command: string      # The command from the commands script to run.
	...depsets: string   # The dependency sets to obtain the dependencies in and give them to the command.
	--dir (-d): path     # Use a different directory for depman to operate in
	--debug (-b)         # For debugging.
]: nothing -> nothing { ignore
	$env.prt_json = $debug
	let depsets: list<string> = (
		$depsets 
		| do-if ($in | is-empty) { ['default'] }
	)
	let dir: path = (
		$dir 
		| default (find-dir $DEPMAN_DIR)
		| default ([. $DEPMAN_DIR] | path join)
	)
	if not ($dir | path exists) {
		print $"No ($dir | path basename | fmt dir) directory found. Do you want to create one at path ($dir | fmt dir)? \(Y/n\)"
		[Yes No] | input list -f
		| if $in == 'Yes' {
			main init
		}
		exit
	}
	let config_defaults: record = (
		$default_paths
		| items {|key, value|
			{$key: ([$dir $value] | path join)}
		}
		| into record
		| insert default-command null
	)

	let config_toml: path = [ $dir 'config.toml'] | path join
	let config = (
		if ($config_toml | path exists) {
			open-toml $config_toml
		} else { {} }
	)
	
	let depman_config = parse_depman_config $config $config_defaults
	$depman_config
	| select out-dir cache-dir
	| items {|_, path| ensure-dir $path}

	if not ($depman_config.commands_script | path exists) {
		error -t 'No commands file' $"Can't find a ($depman_config.commands_script | path basename | fmt file) file in ($dir | fmt dir)." --hint $"Run ($'($CLI_NAME) init' | fmt cmd) to create a starting template."
	}
	let dep_locks: any = parse_lockfile
	let all_commands: table<name: string, fresh-start: bool, out-dir: path> = parse_commands $config
	let command: string = $command | default $depman_config.default-command
	err-if ($command not-in $all_commands.name) $"The given command ($command | fmt cmd) cannot be found in ($depman_config.commands_script | fmt)."
	let dependencies = parse_dependencies
	let all_depsets = parse_depsets $config $dependencies
	$depsets
	| all-in $all_depsets.name --error {|depset| $"The specified depset ($depset | fmt depset) cannot be found in ($config_toml | fmt) or ($depman_config.dependencies_file | fmt)."}
	$depsets
	| each {|depset|
		let depset_config = (
			$all_depsets
			| where name == $depset
			| get 0
		)
		$depset_config.deps
		| each {|dep_name|
			let source: record = (
				$dependencies
				| where name == $dep_name
				| get 0.sources
				| with {|sources|
					where depset == $depset
					| do-if ($in | is-empty) { $sources | where depset == 'default' }
				}
				| get 0.value
			)
			
			{name: $dep_name}
			| insert src-hash ($source | to nuon | hash md5)
			| insert dir {|rec| [$depman_config.cache-dir $rec.src-hash] | path join}
			| insert lock (determine_lock $depset_config $dep_name)
			| merge (compute_cmd $in.dir $source)
		}
		| run-each {|dep|
			if not ($dep.dir | path exists) { mkdir $dep.dir }
		}
		| run-if ($in | all {ls -a $in.dir | is-not-empty}) { say -i 1 $'All dependencies for depset ($depset | fmt depset) are already obtained.' }
		| run-if ($in | any {ls -a $in.dir | is-empty}) {
			say -i 1 'Obtaining dependencies for depset ' ($depset | fmt depset)
		}
		| run-each {|dep|
			mkdir $dep.dir
			if (ls -a $dep.dir | is-empty) {
				[
					(say -o -i 2 "Obtaining dependency " ($dep.name | fmt dep) '...')
					...($dep.cmd-str | lines | each {|line| say -o -i 3 $line })
				]
				| str join "\n"
				| say $in "\n"
				try { 
					do $dep.cmd
					| if ($in | is-type --structured 'record<stdout: string, stderr: string, exit_code: int>' ) {
						if $in.exit_code != 0 {
							error $in.stderr --title $"Can't obtain the dependency ($dep.name | fmt dep)"
						}
					}
				} catch {|err| 
					$err 
					| parse-error
					| update title {$"Can't obtain dependency ($dep.name | fmt dep): ($in | ans attr_bold)" }
					| error $in
				}
			}
		}
		| run {|deps|
			say -i 1 $"Running the command ($command | fmt cmd)..."
			let dependency_dirs = $deps | select name dir | transpose -rd
			let source_dir: path = $dir | path parse | get parent | err-if ($in == null) $"You can't use the system root directory as the ($NAME) directory."
			let out_dir: path = (
				$all_commands
				| where name == $command
				| get 0.out-dir
				| default (
					$depman_config.out-dir
					| path join ( 
						if $depset == default { $command } else { $"($command)_($depset)" } 
					)
				)
			)
			
			if ($all_commands | where name == $command).0.fresh-start {
				rm -rf $out_dir
				mkdir $out_dir
			}
			{dependency-dirs: $dependency_dirs, source-dir: $source_dir, out-dir: $out_dir}
			| to nuon
			| nu --stdin -c $"
				let args = $in | from nuon
				cd '($out_dir)'
				use '($depman_config.commands_script)';
				commands ($command) $args.dependency-dirs $args.source-dir $args.out-dir
				ignore
			"
			| complete
			| if $in.exit_code != 0 {
				error ($"The command aborted with exit code ($in.exit_code | ans xred).\n" + $in.stderr) --title $"Error running the command ($command | fmt cmd)"
			} else {
				say -i 1 $"Successfully ran ($command | fmt cmd)."
			}
		}
	}

	def determine_lock [
		depset_config: record
		dep_name: string
	]: nothing -> bool { ignore
		let in_lock_list = $dep_name in $depset_config.lock-list
		let in_no_lock_list = $dep_name in $depset_config.no-lock-list
		let default = $depset_config.lock
		$in_lock_list or (not $in_lock_list and not $in_no_lock_list and $default)
	}
	
	def compute_cmd [
		cache_dir: path
		source_value: record<type, description, depman-cmd> 
	]: nothing -> record<cmd: closure, cmd-str: string> { ignore
		{$source_value.type: $source_value.description}
		| match $in {
			{git: $repo} => {
				let ref = [$repo.commit? $repo.branch?] | where $it != null | get -i 0
				if $ref != null {
					{ 
						cmd: { git clone -b $ref $repo.url $cache_dir | complete },
						cmd-str: $"git clone -b '($ref)' '($repo.url)' '($cache_dir)'"
					}
				} else {
					{
						cmd: { git clone $repo.url $cache_dir | complete },
						cmd-str: $"git clone '($repo.url)' '($cache_dir)'"
					}
				}
			},
			{http: $request} => {
				let redirect_mode: string = $request.redirect-mode? | default 'error'
				let file_path: path = [$cache_dir ($request.url | url to-filename )] | path join
				{
					cmd: { http get --redirect-mode $redirect_mode $request.url | save -f $file_path },
					cmd-str: $"http get --redirect-mode '($redirect_mode)' '($request.url)' \n| save -f '($file_path)'"
				}
			},
			{path: $path} => {
				let path: path = $path | path expand --strict
				if $path ends-with $path_separator {{ 
					cmd: {cp -r ($path) ($cache_dir)},
					cmd-str: $"cp -r ($path) '($cache_dir)'"
				}} else {{
					cmd: {cp ($path) ($cache_dir)} 
					cmd-str: $"cp ($in) ($path) '($cache_dir)'"	 
				}}
			},
			{rsync: $source} => {
				let source = $source | path expand --strict | str trim -r -c '/'
				{
					cmd: {rsync -az $source $cache_dir | complete },
					cmd-str: $"rsync -az '($source)' '($cache_dir)'"
				}
			},
			{cmd: $command} => {
				cmd: { $env.out_dir = $cache_dir; nu -c $command | complete },
				cmd-str: $"nu -c '($command)'"
			}
		}
	}

	def parse_depsets [config: record, dependencies: any]: nothing -> table<name: string, lock: bool, lock-list: list<string>, no-lock-list: list<string>, deps: list<string>> { ignore	
		$config.depsets?
		| default {}
		| transpose name value
		| with {|depsets|
			$dependencies
			| get sources
			| flatten
			| get depset
			| uniq
			| wrap name 
			| insert value {{}}
			| transpose -r
			| merge ($depsets | transpose -r)
			| transpose name value
		}
		| each {|it|
			$it.value
			| check-type record -m {|value, value_type| $"The value specified for depset ($it.name | fmt depset) in ($config_toml | fmt) is invalid: \n($value) \n\nThe value must be a record specifying the configuration for the dependency set."}
			| run  {
				columns
				| all-in  ['lock' 'lock-list' 'no-lock-list' 'deps' 'no-deps'] --error {|key, valid_keys| $"Unrecognized key ($key | fmt input) found in the configuration of the depset ($it.name | fmt depset) in ($config_toml | fmt). Valid keys are one of ($valid_keys | recount)." }
			}
			| err-if ((type-of $in.deps?) == 'list' and ($in.deps? | is-empty)) "The value given for key ($"depsets.($it.name).deps" | fmt key) in ($config_toml | fmt) is an empty list. A dependency set must contain at least one dependency."
			| defaults {
				lock: true,
				lock-list: [],
				deps: [],
				no-lock-list: [],
				no-deps: [],
			}
			| run {|value|
				$value.lock
				| check-type bool -m {|value, value_type| $"The value given for key ($"depsets.($it.name).lock" | fmt key) in ($config_toml | fmt) has a type of ($value_type | fmt type): \n($value) \n\nType of the value must be ('boolean' | fmt type)."}
				[lock-list no-lock-list deps no-deps]
				| each {|key|
					$value
					| get ([$key] | into cell-path)
					| check-type --structured 'list<string>' -m {|value, value_type, accepted_types| $"The value given for key "depsets.($it.name).($key)" in \"($config_toml)\" has a type of \"($value_type)\": \n($value) \n\nType of the value must be ($accepted_types)."}	
				}
				$value 
				| select lock-list no-lock-list
				| items {|key, value|
					$value 
					| filter {$in not-in $dependencies.name}
					| err-if ($in | is-not-empty) $'The dependency "($in.0?)" specified in "($config_toml)" for the ($key) for depset "($it.name)" cannot be found in "($depman_config.dependencies_file)".'
				}
				err-if ($value.lock == false and ($value.no-lock-list | is-not-empty)) $'You set both "depsets.($it.name).lock" to false and "depsets.($it.name).no-lock-list" to a non-empty list in "($config_toml)". They are mutually exclusive.'
				err-if (($value.deps | is-not-empty) and ($value.no-deps | is-not-empty)) $'You set both "depsets.($it.name).deps" and "depsets.($it.name).no-deps" in "($config_toml)". They are mutually exclusive.'
				err-if ($value.lock == true and ($value.lock-list | is-not-empty)) $'You set both "depsets.($it.name).lock" to true and "depsets.($it.name).lock-list" to a non-empty list in "($config_toml)". They are mutually exclusive.'
			}
			| update deps {|value|
				do-if ($in | is-empty) {
					$dependencies.name
					| filter {$in not-in $value.no-deps}
				}
			}
			| reject no-deps
			| { name: $it.name, ...$in }
		}
	}
 
	def parse_commands [config: record]: nothing -> table<name: string, fresh-start: bool, out-dir: path> { ignore
		def parse_commands_script []: nothing -> list<string> { ignore
			nu -c $"
				use ($depman_config.commands_script);
				scope modules
				| where name == 'commands'
				| get commands.0.name
				| to nuon
			"
			| complete
			| do-if ($in.exit_code != 0) {
				error ($"Error parsing the commands script ($depman_config.commands_script | fmt file).\n($in.stderr)") --title $"Can't parse ('commands.nu' | fmt file)"
			}
			| get stdout
			| from nuon
		}
		let defined_commands = parse_commands_script

		$config.commands?
		| default {}
		| transpose name value
		| run {|commands|
			$commands.name
			| all-in $defined_commands --error {|cmd| $"The command \"($cmd)\" found in \"($config_toml)\" has no definition in \"($depman_config.commands_script)\"." }
		}
		| with {|commands|
			$defined_commands
			| wrap name 
			| insert value {{}}
			| transpose -r
			| merge ($commands | transpose -r)
			| transpose name value
		}
		| each {|it|
			$it.value
			| check-type record -m {|value, value_type| $"Invalid value for key "commands.($it.name)" in \"($config_toml)\". Type of the value must be record. Found value of type \"($value_type)\":\n($value)" }
			| run {
				columns
				| all-in  ['fresh-start' 'out-dir' ] --error {|key, valid_keys| $"Unrecognized key \"($key)\" under [commands] in file \"($config_toml).\". Valid keys are ($valid_keys | recount --and)." }
			}
			| defaults {
				fresh-start: true,
				out-dir: null
			}
			| run {|value|
				$value.fresh-start
				| check-type bool -m {|value, value_type| $"The value given for key \"commands.($it.name).fresh-start\" in \"($config_toml)\" has a type of \"($value_type)\": \n($value) \n\nType of the value must be boolean."}
				$value.out-dir
				| do-if ($in != null) {
					check-type string -m {|value, value_type| $"The value given for key \"commands.($it.name).out-dir\" in \"($config_toml)\" has a type of \"($value_type)\": \n($value) \n\nType of the value must be string."}
				}
			}
			| {name: $it.name, ...$in}
		}
		| run {
			get name
			| err-if-any {|name| $name in [cache retrieve obtain update]} {|cmd| {message: $"One of the commands you defined in ($depman_config.commands_script | fmt file) uses reserved name ($cmd | fmt cmd).", title: "Command uses reserved name", hint: "Rename the command."}}
		}
	}
	
	def parse_lockfile []: nothing -> any { ignore
		do-if ($depman_config.lockfile | path exists) {
			open $depman_config.lockfile
			| from json
			| check-type 'table<src_hash: string, content_hash: string>' --structured -m {
				$"Invalid lockfile at ($depman_config.lockfile). Did you modify it by hand? \nPlease either remove it to regenerate or restore it to its previous state."
			}
		}
	}

	def parse_depman_config [config: record, config_defaults: record]: [nothing -> 
		record<
			out-dir: path,
			cache-dir: path,
			dependencies_file: path,
			lockfile: path,
			commands_script: path,
			default-command: string
		>
	] { ignore
		$config.depman?
		| default {}
		| check-type 'record' -m {$'Invalid value for key "depman" in "($config_toml)". Type of the value must be record.'}
		| run {
			columns
			| all-in ['out-dir', 'cache-dir', 'default-command'] --error {|key, valid_keys| $"Unrecognized key \"($key)\" under [depman] in file \"($config_toml).\". Valid keys are one of ($valid_keys | recount)." }
		}
		| defaults $config_defaults
	}

	def parse_dependencies []: [ nothing ->
        table<
            name: string,
            sources: table<
                depset: string
                value: record<
                    type: string,
                    description: any, # string | record
                    depman-cmd: string
                >
            >
        >] { ignore
		do-if ($depman_config.dependencies_file | path exists) {
			open-toml $depman_config.dependencies_file
			| default {}
			| (transpose name sources)
			| update sources {|dep|
				let alt_depsets: list<string> = (
					$dep.sources
					| columns
					| filter {|key| $key not-in [http git path rsync cmd depman-cmd]}
				)
				let alt_depset_sources = (
					if ($alt_depsets | is-not-empty) { 
						$dep.sources | select ...$alt_depsets
					} else {
						{}
					}
				)
				let def_source = (
					$dep.sources 
					| reject ...$alt_depsets
					| err-if ($in | is-empty) $'You did not specify a default dependency source for dependency "($dep.name)".'
				)
				{ 
					...{default: $def_source},
					...$alt_depset_sources
				}
				| transpose depset value
				| update value {|source|
					let key_loc_str: string = (
						$' for dependency ($dep.name | fmt dep)'
						| do-if ($source.depset != default) { 
							$' in depset ($source.depset | fmt depset)' + $in
						}
					)

					$source.value
					| filter-one $'There are multiple sources($key_loc_str).' (unexpected-error "parse_dependencies: No sources for $source.value.")
					| check-type 'record' --err-msg {|value, value_type|
						$"The value specified for depset \"($source.depset)\" for dependency \"($dep.name)\" is invalid: \n($value) \n\nA dependency set must be a record with keys specifying a source for the dependency."}
					| reject -i depman-cmd
					| transpose type description -d
					| insert depman-cmd $source.value.depman-cmd?
					| run {|source_value|
						match $source_value.type {
							'git' => { 
								let repo = $source_value.description
								$repo.url?
								| check-type 'string' --err-msg {|value, value_type|
									if $value_type == 'nothing' {
										$'You specified a git repository source($key_loc_str) but did not specify a remote url.'
									} else {
										$"The given url value for the git repository source($key_loc_str) has a type of \"($value_type)\": \n($value) \n\nType of the value must be string."
									}
								}
								[ $repo.commit? $repo.branch? ]
								| filter-one --allow-none { error $'You specified both commit and branch in the repo source($key_loc_str) for dependency "($dep.name)". You can only specify one.' }
							},
							'http' => {
								let http = $source_value.description
								$http.url?
								| check-type 'string' --err-msg {|value, value_type|
									if $value_type == 'nothing' {
										$'You specified a http source($key_loc_str) but did not specify the url.'
									} else {
										$"The given url value for the http source($key_loc_str) has a type of \"($value_type)\": \n($value) \n\nType of the value must be string."
									}
								}
								$http.redirect-mode?
								| do-if ($in != null) {
									check-type 'string' --err-msg {|value, value_type| $"The given redirect-mode value for the http source($key_loc_str) has a type of \"($value_type)\": \n($value) \n\nType of the value must be string."}
									| err-if ($in not-in ['follow' 'error']) $"The given redirect-mode value for the http source($key_loc_str) is invalid: \n($http.redirect-mode?) \n\nThe value must be either \"follow\" or \"error\"."
								}
							},
							'path'|'rsync'|'cmd'|'depman-cmd' => {
								$source_value.description
								| check-type 'string' --err-msg {|value, value_type|
									$"The given value for the ($source_value.type) source($key_loc_str) has a type of \"($value_type)\": \n($value) \n\nType of the value must be string."
								}
								| do-if ($source_value.type in ['path' 'rsync']) {
									try { path expand --strict } catch { 
										error --title "Can't find path" $"The given ($source_value.type) source($key_loc_str) can't be expanded: ($source_value.description | fmt path)" --hint "Is there an item at the specified path?"
									}
								}
							},
							_ => { error $'Unrecognized source type "($source_value.type)"($key_loc_str) for dependency "($dep.name)".' }
						}
					}
				}
			}
		}
	}

	def unexpected-error [situation: string] {
		$"An unexpected error occurred. We're sorry about this. In order for this issue to be fixed as soon as possible, please report it at ($"($GITHUB_URL)/issues" | ansi link | ans blue) with the following information: \nCause of error: ($situation) \n($NAME) version: ($VERSION)".
	}
}

# Initiate Depman in your project.
def 'main init' [
	project_dir?: path   # Path to the project directory. (default: current directory)
]: nothing -> nothing { ignore
	let project_dir: path = $project_dir | default '.'
	let depman_dir = [$project_dir $DEPMAN_DIR] | path join
	err-if ($depman_dir | path exists) $"The directory \"($depman_dir)\" already exists. If you want to re-initialize ($NAME), remove it before running \"($CLI_NAME) init\"."
	mkdir $depman_dir
	if (ls $depman_dir | is-empty) {
'export def build [dependency_dirs, source_dir, out_dir] {
	# Write your build script here.

}
'
		| save -f ([$depman_dir 'commands.nu'] | path join)
	}
}

def open-toml [path: path]: nothing -> record { ignore
	try {
		open $path
	} catch {|err|
		$err
		| parse-error
		| update title "TOML parse error"
		| update message {|rec|
			$err.debug
			| parse -r '(?<hint>TOML parse error at line \d+, column \d+)'
			| get 0.hint
			| $in + $' in file ($path | fmt file).'
		}
		| reject hint
		| error $in
	} 
}

# Run a closure on each row of the input list without disrupting the pipeline.
def run-each [
	closure: closure   # A closure to run. Input: the repeat item (any). Parameters: the repeat item (any).
]: any -> any {
	let input = $in
	$input | each $closure
	$input
}

# Run a closure in parallel on each row of the input list without disrupting the pipeline.
def run-par-each [
	closure: closure      # A closure to run. Input: the repeat item (any). Parameters: the repeat item (any).
	--threads (-t): int   # The number of threads to use. 
]: any -> any {
	let input = $in
	if $threads != null {
		$input | par-each --threads $threads $closure
	} else {
		$input | par-each $closure
	}
	$input
}

# Run a closure on the input without disrupting the pipeline.
def run [
	closure: closure   # A closure to run. Input: the input (any). Parameters: the input (any).
]: any -> any {
	let input = $in
	$input | do $closure $input
	$input
}

# Run a closure on the input conditionally without disrupting the pipeline.
def run-if [
	condition: bool    # A condition to check for.
	--not              # Negate the condition.
	closure: closure   # A closure to run. Input: the input (any). Parameters: the input (any).
]: any -> any {
	let input = $in
	if $condition xor $not { $input | do $closure $input }
	$input
}

# Convert the list into an English recounting.
def recount [
	--and (-a)         # Delimit the last item with 'and' instead of 'or'.
	--no-quotes (-n)   # Don't put quotes around items.
]: list<string> -> string {
	do-if --not $no_quotes { each { $'"($in)"'} }
	| chunks ($in | length | [($in - 1), 1] | math max)
	| each { str join ', ' }
	| str join (
		if $and {' and '} else {' or '} 
	)
}

# Assigns default values to keys of a record or list of records.
def defaults [defaults: record]: [list<record> -> list<record>, record -> record] {
    each {|it|
        $defaults
        | merge $it
    }
}

def prt [value?: any, --json (-j)]: any -> any {
	run {
		[$value, $in]
		| filter-one { first } 'prt: No value argument or input is provided.'
		| traverse {
			do-if (($in | describe) == closure) {'<Closure>'} 
		}
		| if ($json or $env.prt_json) {
			to json
		} else {
			to nuon	
		}
		| print $in
	}
}

# Say something to the user. 
# This command returns the input as-is.
def say [
	...message: string   # The message to tell the user.
 	--ansi (-a): any     # (list<string> | string) Apply the ANSI escape codes whose names are given to the message
	--indent (-i): int   # Indent the meesage with spaces
	--output (-o)        # Output the constructed string instead of printing it
]: any -> any {
	let input = $in
	let indent = $indent | default 0
	$message
	| str join ''
	| do-if ($ansi != null) {|str|
		$ansi
		| do-if ($in | is-type 'string') { [$in] }
		| check-type --structured 'list<string>' -m {|value, value_type| $"say: The value given to flag --ansi (-a) has a type of ($value_type): \n$value \n\n The type of the value must be either string or list<string>."}
		| reduce {|it, acc| $acc | ans $it } -f $str
	}
	| $"(arw $indent)($in)"
	# | do-if $error { $"Error:   ('×' | ans red) ($in)"}
	| do-if --not $output {
		print $in
		$input
	}
}

# Print an error with the given message and exit the program.
def error [
	message: any            # (string | record) An error message string or a record with fields <message: string, title?: string, hint?: string, source?: string> to display.
	--hint (-h): string     # (optional) Display a hint
	--title (-t): string    # (optional) Display a title
	--source (-s): string   # (optional) Display a source for the error
]: nothing -> nothing { ignore
	let record = do-if ($message | is-type record) {$message}
	if $record != null and (
		($record.message? | is-type --not string) or
		($record.hint? | is-type --not string nothing) or
		($record.title? | is-type --not string nothing) or
		($record.source? | is-type --not string nothing) or
		not ($record | columns | all-in [message hint title source])
	) {
		(_error $"The given error message doesn't match type ('record<message: string, hint?: string, title?: string, source?: string>' | fmt type): \n\n($record)" 
			$"Run ('error --help' | fmt cmd) for more information."
			$"Type mismatch" 
			'error')
	}
	
	let message = if $record != null { $record.message } else { $message }
	let hint = if $record != null { $record.hint? } else { $hint }
	let title = if $record != null { $record.title? } else { $title }
	let source = if $record != null { $record.source? } else { $source }

	def _error [message, hint?, title?, source?] {
		let no_title = $title == null
		let title = if $no_title { $message } else { $title }
		let message = if $no_title {} else { $message }
		if ($title | str contains "\n") {
			(_error $"The text of the provided error contains newlines: \n($title | to nuon)" 
				$"Remove newlines from the (if $no_title {"message"} else {"title"})." 
				$"Newlines in provided error text" 
				'error')
		}
		if $source != null and ($source | parse -r '\s' | is-not-empty) {
			(_error $"The source of the provided error contains whitespace: \n($source)" 
				"Remove whitespace from the source."
				$"Whitespace in provided error source" 
				'error')
		}
		$"(('Error' | ans red) + ':' | ans attr_bold)   ('×' | ans red) (if $source != null {$source | ans navy attr_bold | $in + ': '} else {''} )($title | do-if --not $no_title {ans attr_bold })"
		| do-if ($message != null) { 
			$in + "\n ├\n" + (($message | str trim) + (if $hint != null {"\n"} else {''}) | str replace --all -m '^(.*)$' $" │ $1")
			| if ($hint == null) { 
				$in + "\n └" 
			} else {
				$in + "\n ╰── "
			}
		}
		| do-if ($hint != null) { $in + ($'hint: ($hint)' | ans blueviolet attr_bold) }
		| print $in
		exit 1
	}
	
	_error $message $hint $title $source
}

# Get the base type of a value provided either as an argument or from the input. 
# Base types comprise 'list', 'record', and all basic types. Tables are recognized as lists.
def type-of [value: any]: nothing -> string { ignore
	$value
	| describe --detailed
	| get type
}

# Run a closure on every basic value contained in structured values.
def traverse [
	closure?: closure            # If given, run this closure on every basic value. Parameters: the input value (any). Input: the basic value (any).
	--structured (-s): closure   # If given, run this closure on structured values themselves and use the output for further traversal. Parameters: the input value (any). Input: the structured value (any). 
	--keep-input (-k)    	     # Output the input unchanged.
]: any -> any {
	let input = $in | collect
	def _traverse [closure: closure, structured: closure]: any -> any {
		match (type-of $in) {
			'list' => {
				do $structured $input
				| each {|it|
					$it | _traverse $closure $structured
				}
			}
			'record' => {
				do $structured $input
				| items {|key, value|
					$value
					| _traverse $closure $structured
					| {$key: $in}
				}
				| reduce -f {} {|it, acc| $acc | merge $it}
			}
			_ => {
				do-if ($closure != null) {
					do $closure $input
				}
			}
		}
	}
	$input
	| _traverse ($closure | default {||}) ($structured | default {||})	
	| do-if $keep_input { $input }
}


# Check that the input list has only one non-nothing item. If so, return it. Otherwise error with given message.
def filter-one [
	multiple: any               # (string | closure) If multiple items match, error with the given message string or execute the given closure on matching items and return the result. Input: matching items (list<any>). Parameters: input list (list<any>). Output: string.
	none_err?: any              # (string | record) If given, error with the given string or description if no items match. Error description syntax is the same as 'error' command.
	--allow-none (-n)           # If given, don't error if no items match.
	--predicate (-p): closure   # If given, test whether elements in the input list fullfill this predicate instead. Input: input list (list<any>). Parameters: repeat item (any). Output: bool.
]: list<any> -> any {
	let input = $in | collect
	if $allow_none == false and $none_err == null {
		error "filter-one: You left the second argument \"none_err\" empty but you didn't specify the \"--allow-none (-n)\" flag."
	}
	let multiple_type = $multiple | describe
	if not ($multiple | is-type 'string' 'closure') {
		error $'filter-one: Received a value with a type of "($multiple_type)" for "multiple" argument. The value must have a type of either string or closure.'
	}	
	$input
	| filter ($predicate | default {|it| $it != null})
	| match ($in | length) {
		0 => { do-if ($none_err != null) { error $none_err } },
		1 => { $in | first },
		_ => {
			if $multiple_type == closure {
				do $multiple $input
			} else if $multiple_type == string {
				error $multiple
			}
		}
	}
}

# Check type of input, and throw an error if it doesn't match.
def check-type [
	...types: string          # Type descriptions to check for. Syntax is the same as 'describe' command output.
	--source (-s): string     # Source of the value. If given, create an error message with the source.
	--err-msg (-m): closure   # A closure to generate a customized error message with. Parameters: input value (any), input value type (string), an English recounting of accepted types (string). Expected output: {message: string, hint: hint}.
	--loc-str (-l): string    # A string describing where the value came from. If given, generate an error message with this string.
	--structured (-e)         # Match nested/structured data types, instead of just the base type.
	]: any -> any {
	let input = $in

	let error = (
		[
			[name       value       flag             ];
			[source     $source     '--source (-s)']
			[err-msg    $err_msg    '--err-msg (-m)' ]
			[loc-str    $loc_str    '--loc-str (-l)' ]
		] 
		| filter-one --predicate {|row| $row.value != null}
			{error -s 'check-type' --title "Multiple flags provided" $"You provided ($in | columns | recount --and) flags. Please provide only one." }
			{source: 'check-type', title: 'Necessary flags are not provided', message: $'You must provide at least one of the flags ($in | columns | recount).' }
	)
	$types | _check-type {types: ['list<string>'], source: 'check-types', structured: true}
	$input | _check-type {types: $types, source: $source, structured: $structured}
	
	def _check-type [args: record<types: list<string>, source: any, structured: bool>]: any -> nothing {
		let value = $in
		let types = $args.types
		let source = $args.source
		let structured = $args.structured

		if $structured {
			$value | is-type --structured ...$types
		} else {
			$value | is-type ...$types
		}
		| if not $in {
			let types_str: string = $types	| each {fmt type} | recount --no-quotes
			let value_type: string = $value | describe
			match $error.name {
				source => { source: $error.value, message: $"The given value has a type of ($value_type | fmt type): \n($value)", hint: $"Accepted types are ($types_str)." }
				loc-str => { message: $"The specified value ($error.value) has a type of ($value_type | fmt type): \n($value)", hint: $"Accepted types are ($types_str)." }
				err-msg => { 
					do $error.value $value $value_type $types_str 
					| err-if ((not ($in | is-type 'record')) or ($in.message? == null or $in.hint? == null)) $"check-type: Output of the closure passed in with --err-msg \(-m\) flag doesn't match the type ('record<message: string, hint: string, title?: string>' | fmt type)."
				}
			}
			| {title: "Type mismatch", ...$in}
			| error $in
		}
	}

	$input
}

# Check whether the input matches a given list of types.
def is-type [
	...types: string    # Type descriptions to check for. Syntax is the same as 'describe' command output.
	--structured (-e)   # Match nested/structured data types, instead of just the base type.
	--not               # Negate the result.
	]: any -> any {
	let value = $in
	let value_type: string = do {
		$value 
		| describe
		| do-if (not $structured) { get-basic-type }
	}
	$types
	| err-if-any {|type|
		let is_structured_type = ($type | get-basic-type) != $type
		$structured != $is_structured_type
	} {|type|
		if $structured {
			$"is-type: You specified the --structured \(-s\) flag but provided a basic data type to check against: \"($type)\". \nPlease provide a structured type instead, like \"list<string>\"."
		} else {
			let simple_type: string = $type | get-basic-type
			$"is-type: You didn't specify the --structured \(-s\) flag but provided a structured data type to check against: \"($type)\". \nPlease provide a simple type instead, like \"($simple_type)\"."
		}
	}

	($value_type in $types) or (	
		# An empty list should match a list containing any type.
		# TODO: The current method can't work on lists nested inside other data types. For this to work, we need to match the output of describe --detailed. It contains information about whether the list is empty too.
		$value_type == 'list<any>' and
		($value | is-empty ) and
		($types | any {($in | get-basic-type) == 'list'})
	)
	| $in xor $not
}

# Get the basic type from a type description.
def get-basic-type []: string -> string {
	str replace --regex '<.*' ''
}

# Check values in a pipeline against a condition and error if check fails.
# The difference with each { err-if } is err-if-any will only accept list input.
def err-if-any [
	condition: closure   # A condition to check with every item. Input: repeat item (any). Parameters: repeat item (any). Output: bool.
	error_msg: closure   # A closure to generate an error message with. Input: failed item (any). Parameters: failed item (any), input list (list<any>). Output: (string | record).
	--not                # Negate the condition.
]: [list<any> -> list<any>] {
	let list = $in
	$list
	| each {|it|
		err-if ($not xor ($it | do $condition $it)) ($it | do $error_msg $it $list)
	}
}

# Check the input against a condition and error if check passes.
def err-if [
	condition: bool   # A condition to check for.
	message: any      # (string | record) An error message string or a record with fields <message: string, title?: string, hint?: string> to display.
	--not             # Negate the condition.
]: any -> any {
	do-if ($condition xor $not) {
		error $message
	}
}

# Conditionally run a closure on the input.
def do-if [
	condition: bool   # A condition to check for.
	--not             # Negate the condition.
	then: closure     # A closure to run on input if the condition is true. Input: input (any). Parameters: input (any).
]: any -> any {
	if $condition xor $not {
		$in | do $then $in
	} else { $in }
}

# Run a block with the input passed as the first parameter.
def with [
	closure: closure   # The closure to run.
]: any -> any {
	do $closure $in
}

# Test if every element in the input is an item in a list, is part of a string, or is a key in a record.
def all-in [
	operand: any            # A string, list, or record to check inclusion in.
	--error (-e): closure   # If given, create an error if any given item is not in the input, with an error message created with the given closure. Input: nonexistent item (any). Parameters: nonexistent item (any), the operand (any). Output: string.
]: list<any> -> bool {
	if $error != null {
		err-if-any {|it| $it not-in $operand} {|it| $it | do $error $it $operand}
	} else {
		all {|it| $it in $operand }
	}
}

# Create a file name from a URL.
def 'url to-filename' []: string -> string {
	def get_last_component []: string -> string { parse -r '^.*?([/\\](?<it>[^/\\]{3,255})[^/\\]*)?$' | get it.0 }
	$in
	| url parse
	| with {|it|
		$in.path
		| url decode
		| get_last_component
		| path sanitize
		| do-if (($in | str length) < 3) {
			$it.host + ($it.path | url decode)
			| path sanitize
		}
	}
}

# Sanitize a string to use as a file name.
def "path sanitize" []: string -> string {
	str replace -ra '[\/\?<>\\:\*\|"]'  ''                                  # Windows illegal filename characters
	| str replace -ra '~' ''                                                # Unix home character
	| str replace -ra '[\x00-\x1f\x80-\x9f]' ''                             # Control characters
	| str replace -ra '(?i)^(con|prn|aux|nul|com[0-9]|lpt[0-9])(\..*)?$' '' # Windows reserved names
	| str replace -r '[. ]+$' ''                                            # Windows illegal trailing dot and whitespace
	| str substring ..255                                                   # Windows filename max length
	| str replace -r '^\.+$' ''                                             # Reserved for navigation
}

# Find a directory in parent directories. If not found, returns nothing.
def find-dir [ 
	dir_name: string   # Name of the directory to find.
]: nothing -> any { ignore
	if ($env.PWD | path parse | get parent | is-empty) {
		return null
	}
	ls
	| where name == $dir_name
	| if ($in | is-empty) {
		cd ..
		find-dir $dir_name
	} else {
		return ($in.name.0 | path expand )
	}
}

def arw [length: int]: nothing -> string { ignore
		1..($length - 1)
		| if $length > 1 { each { ' ' } }
		| str join ''
		| do-if ($length > 0) { $in + ('> ' | ans green) }
	
}

def ans [...code: string]: string -> string {
	with {|str|
		$code
		| reduce -f $str {|it, acc|
			$"(ansi $it)($acc)"
		}
		| $"($in)(ansi reset)"
	}
}

# Ensure a directory exists at a certain path.
def ensure-dir [
	dir_path: path   # The path to directory.
	--empty          # Error if directory already exists AND is not empty.
] {
	let path: path = $dir_path | path split | path join
	if not ($path | path exists) {
		mkdir $path
	}
	let type: string = (ls -D $path).type.0
	if $type != dir {
		error $"Can't create the directory ($path). There is already an item named ($path | path basename | fmt $type) in ($path | path dirname | fmt dir)."
	}
	if $empty and (ls $path | is-not-empty) {
		error $"Can't create the directory ($path | fmt dir). There is already a non-empty directory at ($path | fmt dir)\"."
	}
}

# Format an item for display in terminal output.
def fmt [type?: string]: string -> string {
	let path = $in
	let type = (
		$type | default (
			do-if ($path | path exists) {
				ls -D $path
				| get 0.type
			}
		)
	)
	match $type {
		'path'    => [ xyellow ]
		'file'    => [ olive ]
		'dir'     => [ light_cyan ]
		'symlink' => [ xpurplea ]
		'cmd'     => [ light_purple_bold ]
		'depset'  => [ light_blue_bold ]
		'dep'     => [ yellow_bold ]
		'input'   => [ grey62 ]
		'key'     => [ mediumturquoise attr_bold]
		'type'    => [ cyan ]
	}
	| with {|code|
		$path
		| do-if ($type == dir) { path split | path join | $in + $path_separator }
		| do-if ($type == input) { $'"($in)"'}
		| do-if ($code != null) { ans ...$code }
	}
}

def parse-error []: record<msg: string, debug: string, raw: error> -> record<title: string, message: string, hint: string> {
	let $err = $in | check-type --structured 'record<msg: string, debug: string, raw: error>' --source 'parse-error' # todo check actually matters
	let type = $err.debug | parse -r '^(?<type>\w+)' | get 0.type
	$err.debug
	| str replace -r $'^($type) ' ''
	| str replace --all -r 'Some\((.*?)\)' '$1'
	| str replace --all -r ', \w+: Span {.+?}' ''
	| from nuon
	| with {|struct|
		let message = (
			match $type {
				UnsupportedInput => {
					$struct.input | parse "value: '\"{value}\"'"
					| $"($struct.msg)\nThe received input: ($in)"
				}
				DirectoryNotFound => { $"Can't find the directory at path ($struct.dir | fmt dir)" }
				_ => { $struct.msg }
			}
		)
		{
			title: $err.msg,
			message: $message,
			hint: $struct.help?
		}
	}
}